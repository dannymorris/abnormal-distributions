---
title: Multi-group forecasting in R using the split-apply-combine technique
author: Danny Morris
date: "`r Sys.Date()`"
output: 
  blogdown::html_page:
    toc: true
    highlight: pygments
slug: scalable-forecasting-in-r-approach-using-the-split-apply-combine-technique
categories:
  - R
  - Forecasting
  - Big Data
tags:
  - Big Data
  - R
  - Forecasting
editor_options: 
  chunk_output_type: console
---

```{r, include=F}
knitr::opts_chunk$set(echo = TRUE, message = F, warning = F)
```

## About split-apply-combine

This post demonstrates the use of the [split-apply-combine programming strategy](https://www.jstatsoft.org/article/view/v040i01/v40i01.pdf) applied to time series forecasting. Split-apply-combine involves these three steps:

1. *Split* the data into natural groups, e.g. products, lines of business, etc. In R, the resulting object is a list.

2. Define a repeatable set of steps (like a recipe) and *apply* these steps to each group independently. An example recipe might include filtering outliers, fitting a forecast model, and capturing performance metrics using cross validation.

3. *Combine* the results.

In this post, the data is split by retail industry, a forecast model is fit to each industry using Facebook Prophet and evaluated using rolling origin cross validation, then the MAPE metrics are re-combined for further analysis.

## Strengths of this apprach

I like using split-apply-combine for the following benefits:

- Replicate the exact same forecasting methodology (or any other methodology for that matter) for each group independently.

- Parallelizable using a distributed or multi-core environment. I like using `parLapply` in a multi-core Linux environment.

- Highly efficient alternative to developing and evaluating individual forecast models.

## R packages

```{r}
library(tidyverse)
library(prophet)
library(rsample)
```

## Data

```{r}
model_df <- tsibbledata::aus_retail %>%
  as_tibble() %>%
  mutate(Month = as.Date(Month)) %>%
  filter(Month >= "2010-01-01",
         State == "Victoria") %>%
  select(ds = Month,
         y = Turnover,
         State,
         Industry) %>%
  as_tibble()
```

## Objective

The objective is to build a forecasting model for each retail industry in each state. The issue is that there are `model_df %>% count(State, Industry) %>% nrow()` industry-state combinations represented in the data. It would impractical to build and maintain models for each combination. A generalized forecasting procedure applied to each group automatically is far more effecient and repeatable. 

## Split-apply-combine

### Split by industry-state

```{r}
# Splitting results in a list of tibbles
industry_splits <- model_df %>%
  group_by(State, Industry) %>%
  group_split()

# count number of observations per split in order to filter out
# splits with little to no data
rows_per_split <- map_dbl(industry_splits, nrow)
industry_splits <- industry_splits[rows_per_split == 108]
```

### Apply model and return MAPE metrics from ROCV

```{r}
# Configure ROCV
initial_train_obs <- 90         # 1
forecast_horizon <- 12          # 2
accumulate_train_obs <- FALSE   # 4
```

```{r}
library(furrr)

plan(multiprocess)

rocv_models <- industry_splits[1:5] %>%
  map(., function(df) {
    
    rocv_splits <- rsample::rolling_origin(
      data = df,
      initial = initial_train_obs,
      assess = forecast_horizon,
      cumulative = accumulate_train_obs
    )
    
    cv_idx <- seq(1, length(rocv_splits$splits), 1)
    
    rocv <- map2(rocv_splits$splits, cv_idx, function(split, id) {
      
      training <- analysis(split)
      testing <- assessment(split)
      
      prophet_fit <- prophet(df = training,
                             weekly.seasonality = F,
                             yearly.seasonality = F,
                             daily.seasonality = F,
                             seasonality.mode = "multiplicative") 
      
      predict(prophet_fit, testing) %>%
        select(ds, yhat) %>%
        mutate(y = testing$y) %>%
        yardstick::mape(truth = y, estimate = yhat) %>%
        mutate(Iteration = id)
    }) %>%
      bind_rows()
  })
```

### Combine results

```{r}
bind_rows(rocv_models)
```
