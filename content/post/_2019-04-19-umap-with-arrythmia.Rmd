---
title: UMAP with Arrythmia
author: Danny Morris
date: '2019-04-19'
slug: umap-with-arrythmia
categories:
  - Data Mining
  - R
  - Clustering
tags:
  - Data mining
  - R
  - Clustering
editor_options: 
  chunk_output_type: console
---

# Dimension Reduction with UMAP

```{r}
library(tidyverse)
library(caret)
library(uwot)
```

# Data

```{r}
arr <- read_csv(url("https://archive.ics.uci.edu/ml/machine-learning-databases/arrhythmia/arrhythmia.data"), col_names = F) %>%
  mutate_all(funs(as.numeric))
```

As part of the initial data exploration, we can check for features which have little to no variance using `nearZeroVar()` function from the `caret` package.

```{r}
nz_vars <- caret::nearZeroVar(arr)
```

Incomplete variables

```{r}
pct_na <- function(x) {
  sum(is.na(x)) / length(x)
}

which_incomplete <- function(x) {
  which(x > 0)
}

incomplete_rows <- function(tbl) {
  tbl_rows <- split(tbl, seq(nrow(tbl))) %>%
    map(unlist, use.names = F) 
  
  pct_missing <- tbl_rows %>%
    map(pct_na) %>%
    unlist(use.names = F)
  
  tibble(row_index = seq_along(pct_missing),
         pct_missing = pct_missing) %>%
    arrange(desc(pct_missing)) %>%
    filter(pct_missing > 0)
}

incomplete_columns <- function(tbl) {
  pct_missing <- map(tbl, pct_na) %>%
    unlist(use.names = F)
  
  tibble(col_index = colnames(tbl),
         pct_missing = pct_missing) %>%
    arrange(desc(pct_missing)) %>%
    filter(pct_missing > 0)
}
```

```{r}
incomplete_columns(arr)
incomplete_rows(arr)
```


```{r}
z_scale <- function(x) {
  (x - mean(x)) / sd(x)
}

impute_median <- function(x) {
  ifelse(is.na(x), median(x, na.rm=T), x)
}
```

```{r}
arr_clean <- arr %>%
  select(-X14, -nz_vars) %>%
  mutate_at(vars(X12, X11, X13, X15), list(~impute_median)) %>%
  mutate_at(vars(-X280), list(~z_scale))
```

```{r}
arr_X <- arr_clean %>% select(-X280)
arr_Y <- arr_clean %>% 
  mutate(abnormal = ifelse(X280 != 1, "Class_1", "Class_0")) %>%
  select(abnormal)
```

```{r}
pca <- princomp(arr_X)

pca50 <- pca$scores[, 1:50]
```

```{r}
library(uwot)

umap <- uwot::umap(arr_X, n_neighbors = 3, metric = "cosine",
                   y = as.factor(arr_Y$abnormal))

plot(umap, col = arr_Y$abnormal)
```

```{r}
library(ranger)

df_scaled <- as_tibble(arr_scaled) %>% mutate(class = as.factor(arr_Y$abnormal))
df_pca <- as_tibble(pca50) %>% mutate(class = as.factor(arr_Y$abnormal))
df_umap <- as_tibble(umap) %>% mutate(class = as.factor(arr_Y$abnormal))

rf_scaled <- ranger(class ~ ., data = df_scaled) 
rf_pca <- ranger(class ~ ., data = df_pca)
rf_umap <- ranger(class ~ ., data = df_umap, probability = T)

rf_scaled$confusion.matrix
rf_pca$confusion.matrix
rf_umap$confusion.matrix
```

```{r}
library(e1071)


sv <- e1071::svm(class ~ ., data = df_umap)

trc <- caret::trainControl(
  method = "repeatedcv",
  number = 5,
  repeats = 5,
  summaryFunction = caret::multiClassSummary,
  classProbs = T,
  savePredictions = T
)

tr <- caret::train(
  class ~ .,
  data = df_umap,
  method = "svmRadial",
  metric = "AUC",
  trControl = trc
)

df2 <- df_umap %>%
  mutate(pred1 = pr$predictions[, 2]) %>%
  mutate(row_index = row_number()) %>%
  split(.$class) %>%
  map(., function(x) {
    min_x <- x %>% filter(pred1 == min(pred1)) %>% slice(1)
    max_x <- x %>% filter(pred1 == max(pred1)) %>% slice(1)
    
    bind_rows(min_x, max_x)
  }) %>%
  bind_rows()



good <- df2 %>%
  filter(class_max == 1)

kkjkl



```